 🚀 AI Website Assistant - Product Specification

  Product Vision

  An embeddable AI chatbot that learns from any website and provides intelligent, context-aware answers with visual enhancements (popups, maps, highlights). Think "ChatGPT meets Intercom for any website."

  ---
  Core Value Proposition

  For Website Owners (Your Customers)

  - ✅ Reduce support tickets by 60-80%
  - ✅ Improve user experience (instant answers)
  - ✅ No coding required (just embed snippet)
  - ✅ Works in any language
  - ✅ Customizable to match brand

  For Website Visitors (End Users)

  - ✅ Get answers instantly (no searching menus)
  - ✅ Visual responses (maps, highlights, images)
  - ✅ Natural conversation (not keyword search)
  - ✅ Works 24/7

  ---
  Feature Tiers

  FREE Plan (Lead Generation)

  - 1 website
  - Basic Q&A (5 pre-configured questions)
    - Address
    - Opening hours
    - Contact info
    - Simple FAQs
  - 100 conversations/month
  - "Powered by AI Workbench" branding
  - Email support only

  PRO Plan ($29-79/month)

  - 3 websites
  - Full RAG (crawls entire website automatically)
  - 1,000 conversations/month
  - Visual enhancements:
    - Google Maps integration
    - Smart popups with page sections
    - Image/video responses
  - Customization:
    - Remove branding
    - Custom colors, logo, position
    - Custom welcome message
  - Knowledge Base:
    - Upload PDFs (menus, brochures)
    - Manual Q&A editor
  - Analytics:
    - Most asked questions
    - Conversation history
    - User satisfaction ratings
  - Priority support

  BUSINESS Plan ($149-299/month)

  - 10 websites
  - 10,000 conversations/month
  - Advanced features:
    - Multi-language support
    - Lead capture forms
    - CRM integrations (send leads to email/Slack/webhooks)
    - Appointment booking integration
    - WhatsApp/SMS notifications
  - Team features:
    - Multiple team members
    - Role permissions
    - Handoff to human agent
  - White-label option
  - API access
  - Custom training

  ---
  User Flows

  1. Website Owner Setup Flow

  1. Sign up → Choose plan
  2. Dashboard: "Add New Website"
  3. Enter website URL (e.g., www.physioheld.ch)
  4. System automatically:
     - Crawls website
     - Extracts content
     - Generates embeddings
     - Indexes in vector DB
     - [Progress bar: "Crawling pages... 12/45 done"]
  5. Configure chatbot:
     - Upload logo
     - Choose colors (match website)
     - Set position (bottom-right, bottom-left)
     - Write welcome message: "Hi! Ask me anything about Physioheld 👋"
     - Add custom Q&As (optional)
  6. Test in preview window
  7. Copy embed code:
     ```html
     <script src="https://aiworkbench.com/embed.js"
             data-token="pk_live_abc123"></script>
  8. Paste on website → Done! 🎉

  ### **2. End User Experience**

  [Website visitor lands on physioheld.ch]

  [Small chat bubble appears bottom-right: 💬]

  User clicks → Chat opens
  Bot: "Hi! Ask me anything about Physioheld 👋"

  User: "macht ihr auch hausbesuche?"

  Bot: [Thinking... 🤔]
  Bot: ✅ "Ja! Wir bieten Domizilbehandlungen an."
       [Shows popup with highlighted section from website]
       [Button: "Learn more →" → scrolls to that section]

  User: "was ist eure adresse?"

  Bot: 📍 "Physiotherapie Held
       Musterstrasse 123
       8000 Zürich"
       [Embedded Google Maps with marker]
       [Button: "Get directions"]

  User: "öffnungszeiten?"

  Bot: 🕐 "Mo-Fr: 8:00-18:00
       Sa: 9:00-13:00
       So: Geschlossen"
       [Button: "Book appointment"]

  ---

  ## **Technical Architecture**

  ### **System Components**

  ┌─────────────────────────────────────────────────────────┐
  │                    AI Workbench Dashboard                │
  │  (React) - Manage websites, view analytics, configure   │
  └────────────────────┬────────────────────────────────────┘
                       │
                       ↓
  ┌─────────────────────────────────────────────────────────┐
  │                    Backend API (FastAPI)                 │
  │  • Website management                                    │
  │  • Crawling orchestration                                │
  │  • Chat API (receives user questions)                    │
  │  • Analytics & usage tracking                            │
  └────┬──────────┬──────────┬──────────┬──────────────────┘
       │          │          │          │
       ↓          ↓          ↓          ↓
  ┌─────────┐ ┌────────┐ ┌──────────┐ ┌──────────┐
  │ Crawler │ │Vector  │ │OpenAI/   │ │Analytics │
  │ Worker  │ │DB      │ │Claude    │ │DB        │
  │(Celery) │ │Pinecone│ │API       │ │Postgres  │
  └─────────┘ └────────┘ └──────────┘ └──────────┘
                  │
                  ↓
          [Embeddings stored]
                  │
                  ↓
  ┌─────────────────────────────────────────────────────────┐
  │              Embeddable Widget (embed.js)                │
  │  (Vanilla JS) - Injected on customer website             │
  │  • Chat UI                                               │
  │  • Popup/Maps rendering                                  │
  │  • API calls to backend                                  │
  └─────────────────────────────────────────────────────────┘

  ---

  ## **Database Schema**

  ```sql
  -- Websites managed by users
  CREATE TABLE websites (
      id UUID PRIMARY KEY,
      user_id UUID REFERENCES users(id),
      url TEXT NOT NULL,
      name TEXT,
      status TEXT, -- crawling, ready, error
      embed_token TEXT UNIQUE,

      -- Customization
      brand_color TEXT,
      logo_url TEXT,
      welcome_message TEXT,
      position TEXT, -- bottom-right, bottom-left

      -- Settings
      language TEXT,
      crawl_frequency TEXT, -- daily, weekly, manual
      last_crawled_at TIMESTAMP,
      pages_indexed INTEGER,

      created_at TIMESTAMP,
      updated_at TIMESTAMP
  );

  -- Crawled pages from websites
  CREATE TABLE website_pages (
      id UUID PRIMARY KEY,
      website_id UUID REFERENCES websites(id),
      url TEXT,
      title TEXT,
      content TEXT, -- cleaned HTML → plain text
      metadata JSONB, -- headings, images, links
      embedding_id TEXT, -- Pinecone vector ID
      last_crawled_at TIMESTAMP
  );

  -- Custom Q&As added by user
  CREATE TABLE custom_qas (
      id UUID PRIMARY KEY,
      website_id UUID REFERENCES websites(id),
      question TEXT,
      answer TEXT,
      priority INTEGER, -- higher = show first
      created_at TIMESTAMP
  );

  -- Chat conversations
  CREATE TABLE conversations (
      id UUID PRIMARY KEY,
      website_id UUID REFERENCES websites(id),
      visitor_id TEXT, -- anonymous or tracked
      started_at TIMESTAMP,
      ended_at TIMESTAMP,
      messages JSONB, -- [{role, content, timestamp}]
      satisfaction_rating INTEGER -- 1-5 stars
  );

  -- Usage tracking
  CREATE TABLE usage_stats (
      id UUID PRIMARY KEY,
      website_id UUID REFERENCES websites(id),
      date DATE,
      conversations_count INTEGER,
      messages_count INTEGER,
      tokens_used INTEGER,
      cost_usd DECIMAL
  );

  ---
  RAG Implementation Details

  1. Website Crawling Pipeline

  # Celery task
  @celery_app.task
  def crawl_website(website_id: str):
      """
      1. Fetch sitemap.xml or crawl recursively
      2. Extract text from HTML (strip nav, footer, ads)
      3. Chunk text (500-1000 tokens per chunk)
      4. Generate embeddings (OpenAI text-embedding-3-small)
      5. Store in Pinecone with metadata
      """

      website = db.get_website(website_id)

      # Use Scrapy or BeautifulSoup
      pages = crawl_site(website.url, max_pages=100)

      for page in pages:
          # Clean HTML
          text = extract_text(page.html)
          chunks = split_into_chunks(text, chunk_size=800)

          for chunk in chunks:
              # Generate embedding
              embedding = openai.embeddings.create(
                  model="text-embedding-3-small",
                  input=chunk
              )

              # Store in Pinecone
              pinecone.upsert(
                  id=f"{page.url}#{chunk_index}",
                  values=embedding.data[0].embedding,
                  metadata={
                      "website_id": website_id,
                      "url": page.url,
                      "title": page.title,
                      "content": chunk
                  }
              )

  2. Question Answering Flow

  @router.post("/api/chat/{embed_token}/message")
  async def chat_message(
      embed_token: str,
      message: str,
      conversation_id: str | None = None
  ):
      """
      1. Get website by embed_token
      2. Search vector DB for relevant chunks
      3. Build prompt with context
      4. Call LLM
      5. Parse response for actions (map, popup, etc)
      6. Return structured response
      """

      website = db.get_website_by_token(embed_token)

      # Check custom Q&As first (exact/fuzzy match)
      custom_answer = check_custom_qas(website.id, message)
      if custom_answer:
          return {"answer": custom_answer, "source": "custom"}

      # Generate query embedding
      query_embedding = openai.embeddings.create(
          model="text-embedding-3-small",
          input=message
      )

      # Search Pinecone
      results = pinecone.query(
          vector=query_embedding.data[0].embedding,
          filter={"website_id": website.id},
          top_k=5,
          include_metadata=True
      )

      # Build context from top results
      context = "\n\n".join([
          f"From {r.metadata['url']}:\n{r.metadata['content']}"
          for r in results.matches
      ])

      # Call LLM
      response = openai.chat.completions.create(
          model="gpt-4o-mini",
          messages=[
              {"role": "system", "content": f"""
  You are a helpful assistant for {website.name}.
  Answer questions based on the following website content.
  If asked about address, respond with: ADDRESS: <address>
  If asked about hours, respond with: HOURS: <hours>
  If asked about services, respond with: SERVICE: <service> | URL: <page_url>
  """},
              {"role": "user", "content": f"Context:\n{context}\n\nQuestion: {message}"}
          ]
      )

      answer = response.choices[0].message.content

      # Parse for special actions
      actions = parse_actions(answer)
      # actions = {
      #     "type": "map",
      #     "data": {"address": "Musterstrasse 123, Zürich"}
      # }

      # Track usage
      track_usage(website.id, tokens=response.usage.total_tokens)

      return {
          "answer": answer,
          "actions": actions,
          "sources": [r.metadata['url'] for r in results.matches]
      }

  ---
  Embeddable Widget

  // embed.js - Vanilla JS widget
  (function() {
    const token = document.currentScript.getAttribute('data-token');

    // Create chat bubble
    const bubble = document.createElement('div');
    bubble.id = 'ai-chat-bubble';
    bubble.innerHTML = '💬';
    bubble.style.cssText = 'position:fixed;bottom:20px;right:20px;width:60px;height:60px;...';

    // Create chat window
    const chatWindow = document.createElement('div');
    chatWindow.id = 'ai-chat-window';
    chatWindow.style.display = 'none';
    chatWindow.innerHTML = `
      <div id="ai-chat-header">
        <span>AI Assistant</span>
        <button id="ai-chat-close">×</button>
      </div>
      <div id="ai-chat-messages"></div>
      <div id="ai-chat-input-area">
        <input id="ai-chat-input" placeholder="Ask anything..." />
        <button id="ai-chat-send">Send</button>
      </div>
    `;

    document.body.appendChild(bubble);
    document.body.appendChild(chatWindow);

    // Handle message sending
    async function sendMessage(message) {
      const response = await fetch(`https://api.aiworkbench.com/api/chat/${token}/message`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({message, conversation_id: getConversationId()})
      });

      const data = await response.json();

      // Display answer
      appendMessage('bot', data.answer);

      // Handle actions
      if (data.actions?.type === 'map') {
        showMapPopup(data.actions.data.address);
      } else if (data.actions?.type === 'highlight') {
        highlightSection(data.actions.data.selector);
      }
    }

    // ... rest of widget logic
  })();

  ---
  Implementation Plan

  Phase 1: Core RAG System (Week 1-2)

  Tasks:

  1. ✅ Database schema for websites, pages, conversations
  2. ✅ Website crawler (Scrapy/BeautifulSoup + Celery)
  3. ✅ Pinecone integration (vector storage)
  4. ✅ Embedding generation pipeline
  5. ✅ RAG query endpoint (/api/chat/{token}/message)
  6. ✅ Basic dashboard: Add website, view status

  Phase 2: Embeddable Widget (Week 3)

  Tasks:

  1. ✅ Vanilla JS chat widget (bubble + window)
  2. ✅ API integration (send/receive messages)
  3. ✅ Customization options (colors, logo, position)
  4. ✅ Token-based authentication
  5. ✅ Test on demo website

  Phase 3: Visual Enhancements (Week 4)

  Tasks:

  1. ✅ Google Maps integration (detect addresses)
  2. ✅ Smart popups (highlight page sections)
  3. ✅ Action parser (ADDRESS:, HOURS:, SERVICE:)
  4. ✅ Image/link responses

  Phase 4: Dashboard & Analytics (Week 5)

  Tasks:

  1. ✅ Website management UI (list, add, edit, delete)
  2. ✅ Custom Q&A editor
  3. ✅ Conversation history viewer
  4. ✅ Analytics dashboard (usage stats, popular questions)
  5. ✅ Usage limits & billing integration

  Phase 5: Polish & Launch (Week 6)

  Tasks:

  1. ✅ Multi-language support
  2. ✅ Performance optimization (caching, CDN)
  3. ✅ Documentation & setup guide
  4. ✅ Marketing site (landing page)
  5. ✅ Beta launch with 10 test customers

  ---
  Tech Stack

  Backend:

  - FastAPI (Python)
  - PostgreSQL (structured data)
  - Pinecone (vector database) - $70/month for 100k vectors
    - Alternative: Qdrant (self-hosted, free)
  - Celery + Redis (background jobs)
  - OpenAI API (embeddings + chat)

  Frontend:

  - React (dashboard)
  - Vanilla JS (embeddable widget)
  - TailwindCSS (styling)

  Infrastructure:

  - AWS/DigitalOcean (hosting)
  - Cloudflare (CDN for embed.js)
  - Stripe (billing)

  ---
  Pricing Strategy

  Costs per 1,000 conversations:

  - OpenAI embeddings: ~$0.10
  - OpenAI chat (GPT-4o-mini): ~$2-5
  - Pinecone storage: ~$0.50/month
  - Total cost: ~$3-6 per 1,000 chats

  Pricing:

  - FREE: 100 chats/month = $0.30-0.60 cost → Lead gen
  - PRO: 1,000 chats/month @ $49 = $3-6 cost → $43-46 profit (90% margin)
  - BUSINESS: 10,000 chats/month @ $199 = $30-60 cost → $139-169 profit (85% margin)

  ---
  Marketing Angle

  Tagline:

  "Your website, supercharged with AI. Embed in 2 minutes."

  Target Customers:

  1. Local businesses (restaurants, clinics, salons) - "Answer calls 24/7"
  2. E-commerce - "Personal shopping assistant"
  3. SaaS companies - "Reduce support tickets by 80%"
  4. Education - "AI tutor for your course content"

  Growth Strategy:

  1. Free tier → Convert to Pro after seeing value
  2. Productized service → Offer setup for $199 one-time
  3. Affiliate program → Pay web designers 20% recurring
  4. Template marketplace → Sell industry-specific configs

  ---
  Next Steps

  Should I start implementing Phase 1 (Core RAG System)?

  I can build:
  1. Database schema
  2. Website crawler
  3. Pinecone integration
  4. Basic chat endpoint

  OR do you want to refine the plan first?

  This is a SOLID business idea with clear monetization. LMK when to start coding! 🚀
